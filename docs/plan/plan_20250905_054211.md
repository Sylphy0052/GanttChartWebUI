# Phase 2実装計画書

**計画策定日**: 2025-09-05 05:42:11  
**対象**: GanttChartWebUI Phase 2 - 性能最適化・テレメトリ基盤実装  
**ベース**: 調査レポート investigate_20250905_053911.md

---

## 1. 実装方針・目標

### 1.1 実装方針
- **測定先行**: テレメトリ基盤を先に構築し、データ駆動で最適化
- **段階的最適化**: 仮想化→計算最適化→描画最適化の順序で実装
- **リスク管理**: 各段階でベンチマーク実施、フォールバック機能準備

### 1.2 Phase 2の目標
1. **パフォーマンステレメトリ基盤**の完全実装
2. **性能要件の達成**: 初回描画<1.5s、ドラッグ応答<100ms、ズーム<150ms
3. **react-window仮想化**による大量データ対応
4. **SVG描画最適化**による描画効率向上
5. **計算処理最適化**による応答性向上

### 1.3 成功指標
- 性能要件の完全達成（1,000 Issue環境）
- テレメトリによる継続監視の実現
- 既存機能の互換性100%維持

---

## 2. 詳細実装タスク分解

### 2.1 Phase 2.1: テレメトリ基盤実装（2日）

#### タスク2.1.1: Performance Monitor実装（Day 1）
- **T2.1.1.1**: GanttPerformanceMetrics interface定義（2h）
  - 測定項目の型定義
  - メトリクスデータ構造設計
- **T2.1.1.2**: PerformanceMonitor class実装（4h）
  - 測定ロジック実装
  - Performance API統合
  - メモリ使用量監視機能
- **T2.1.1.3**: 基本測定機能テスト（2h）
  - 単体テスト作成
  - 測定精度検証

#### タスク2.1.2: Performance Hook・統合実装（Day 2）
- **T2.1.2.1**: usePerformanceMetrics hook実装（4h）
  - React統合レイヤー実装
  - 状態管理との統合
- **T2.1.2.2**: GanttChart測定ポイント統合（3h）
  - 初回描画時間測定
  - ドラッグ応答時間測定
  - ズーム操作時間測定
- **T2.1.2.3**: 自動アラート・監視機能（1h）
  - 閾値超過時の警告機能
  - デバッグ情報出力

### 2.2 Phase 2.2: 性能最適化実装（2日）

#### タスク2.2.1: 仮想化・描画最適化（Day 3）
- **T2.2.1.1**: react-window仮想化統合（6h）
  - GanttGrid仮想化実装
  - タスクリスト仮想化
  - スクロール同期機能
- **T2.2.1.2**: SVG差分更新実装（2h）
  - 変更検出ロジック
  - 差分描画実装

#### タスク2.2.2: 計算最適化・統合（Day 4）
- **T2.2.2.1**: 依存関係計算最適化（3h）
  - タスクインデックスマップ実装
  - O(n²)→O(n)最適化
- **T2.2.2.2**: セレクター・イベント最適化（3h）
  - メモ化セレクター実装
  - デバウンス強化
- **T2.2.2.3**: 統合テスト・性能測定（2h）
  - E2Eパフォーマンステスト
  - 目標達成確認

---

## 3. ファイル変更計画

### 3.1 新規作成ファイル

#### Performance関連
```
apps/web/src/lib/
├── performance.ts                   # PerformanceMonitor class・interface
└── performance-utils.ts             # 測定ユーティリティ関数

apps/web/src/hooks/
└── usePerformanceMetrics.ts         # パフォーマンス測定フック

apps/web/src/types/
└── performance.ts                   # パフォーマンス型定義
```

#### 最適化関連
```
apps/web/src/components/gantt/optimized/
├── VirtualizedGanttGrid.tsx         # react-window統合版
├── OptimizedTaskRow.tsx             # 仮想化対応タスク行
└── DifferentialSVGRenderer.tsx      # 差分描画SVGレンダラー

apps/web/src/lib/
├── gantt-optimizations.ts          # 最適化ユーティリティ
└── task-indexing.ts                # タスクインデックス管理
```

#### テスト関連
```
apps/web/src/__tests__/performance/
├── PerformanceMonitor.test.ts       # PerformanceMonitor単体テスト
├── usePerformanceMetrics.test.ts    # フック単体テスト
└── gantt-performance.e2e.test.ts    # パフォーマンスE2Eテスト
```

### 3.2 修正対象ファイル

#### コンポーネント修正
```
apps/web/src/components/gantt/
├── GanttChart.tsx                   # 測定ポイント統合
├── GanttGrid.tsx                    # 仮想化・差分描画統合
├── GanttBar.tsx                     # 最適化対応
└── GanttTimeline.tsx                # パフォーマンス改善

apps/web/src/stores/
└── gantt.store.ts                   # セレクター最適化
```

#### ユーティリティ修正
```
apps/web/src/lib/
├── gantt-utils.ts                   # 計算最適化
└── wbs-utils.ts                     # 依存関係計算最適化
```

#### 型定義修正
```
apps/web/src/types/
└── gantt.ts                         # 最適化対応型追加
```

---

## 4. テスト戦略

### 4.1 パフォーマンステスト（必須・最優先）

#### 測定環境
- **データ規模**: 1,000 Issue + 300依存関係
- **ブラウザ**: Chrome DevTools Performance
- **自動化**: Playwright + Performance API

#### 測定項目・基準
```typescript
interface PerformanceTargets {
  initialRenderTime: 1500      // < 1.5秒
  dragResponseTime: 100        // < 100ms
  zoomTransitionTime: 150      // < 150ms
  memoryLeakCheck: true        // リーク無し
  cpuUsageLimit: 80           // CPU使用率 < 80%
}
```

#### 測定シナリオ
```gherkin
Scenario: 初回描画性能
  Given 1,000 Issue データが準備済み
  When Ganttチャート画面を開く
  Then 初回描画が1.5秒以内に完了する
  And メモリ使用量が適正範囲内である

Scenario: ドラッグ操作性能
  Given Ganttチャートが表示済み
  When タスクバーをドラッグする
  Then 100ms以内に応答する
  And 滑らかなアニメーション表示

Scenario: ズーム操作性能
  Given Ganttチャートが表示済み
  When ズーム操作を実行する
  Then 150ms以内に切替完了
  And UI要素が正しく再描画される
```

### 4.2 単体テスト（重要機能）

#### テスト対象
```typescript
// apps/web/src/__tests__/performance/
describe('PerformanceMonitor', () => {
  test('初回描画時間測定の精度')
  test('ドラッグ応答時間測定の精度')
  test('メモリ使用量監視機能')
  test('閾値判定ロジック')
})

describe('usePerformanceMetrics', () => {
  test('フック状態管理')
  test('測定データ蓄積')
  test('アラート機能')
})

describe('GanttOptimizations', () => {
  test('タスクインデックスマップ生成')
  test('差分検出ロジック')
  test('仮想化データ計算')
})
```

### 4.3 統合テスト（パフォーマンス統合）

#### テスト項目
- PerformanceMonitor ↔ React Component統合
- 測定データ → ストア → UI反映の一貫性
- 仮想化 ↔ 既存描画ロジックの協調動作

### 4.4 E2Eテスト（重要シナリオ）

#### テストシナリオ
```gherkin
Scenario: パフォーマンス監視機能
  Given 大量データ環境
  When 各種Gantt操作を実行
  Then 性能指標が正しく収集される
  And 閾値超過時に警告が表示される

Scenario: 仮想化機能
  Given 1,000タスク環境
  When スクロール操作を実行
  Then 滑らかなスクロール動作
  And 画面外タスクが非描画状態

Scenario: 最適化後の機能互換性
  Given 最適化適用済み環境
  When 既存の全Gantt機能を実行
  Then 全機能が正常動作
  And 性能要件を満たす
```

---

## 5. リスク分析・対策

### 5.1 高リスク項目

#### R1: react-window統合の技術的複雑さ（確率:中、影響度:高）
**詳細**: 既存SVG描画ロジックとreact-window仮想化の統合が予想以上に複雑
**影響**: 開発遅延2-3日、統合バグ発生
**対策**:
- **段階的統合アプローチ**: タスクバー→依存関係→グリッドの順序
- **プロトタイプ検証**: Day 2終了時点でPoC実装・検証
- **フォールバック機能**: 仮想化無効化オプション実装
- **専門知識獲得**: react-window公式ドキュメント・サンプル研究

#### R2: 性能目標未達成（確率:中、影響度:高）
**詳細**: 1.5s/100ms/150ms目標の一部または全部が未達成
**影響**: PoC受入基準不合格、Phase 2失敗
**対策**:
- **早期ベンチマーク**: Day 3時点で中間測定実施
- **段階的最適化**: 優先度順に実装、効果測定
- **緊急時妥協策**: データ量制限（500 Issue）での受入
- **代替技術検討**: react-virtualized等の代替案準備

### 5.2 中リスク項目

#### R3: 既存機能への回帰影響（確率:低、影響度:中）
**詳細**: 最適化実装により既存Gantt機能に予期しない影響
**影響**: 機能劣化、ユーザビリティ低下
**対策**:
- **包括的回帰テスト**: 既存E2Eテスト全実行
- **段階的リリース**: 機能別に有効化可能な実装
- **ロールバック準備**: feature flag活用

#### R4: TypeScript型安全性の維持（確率:低、影響度:中）
**詳細**: パフォーマンス最適化により型定義が複雑化
**影響**: 開発効率低下、型エラー増加
**対策**:
- **厳密な型定義**: 最適化前に型設計完了
- **型テスト**: tsd等による型レベルテスト実施

---

## 6. 技術アーキテクチャ詳細

### 6.1 PerformanceMonitor実装

#### クラス設計
```typescript
// apps/web/src/lib/performance.ts
export interface GanttPerformanceMetrics {
  // 基本メトリクス
  initialRenderTime: number        // 初回描画時間（ms）
  dragResponseTime: number[]       // ドラッグ応答時間履歴
  zoomTransitionTime: number[]     // ズーム遷移時間履歴
  
  // システムメトリクス
  memoryUsage: number             // メモリ使用量（MB）
  cpuUsage?: number              // CPU使用率（%）
  
  // コンテキストメトリクス
  taskCount: number              // 描画タスク数
  dependencyCount: number        // 依存関係数
  viewportSize: { width: number; height: number }
  
  // メタデータ
  timestamp: number              // 測定時刻
  browserInfo: string           // ブラウザ情報
  userAgent: string            // UA文字列
}

export interface PerformanceThresholds {
  maxInitialRenderTime: 1500     // 1.5s
  maxDragResponseTime: 100       // 100ms
  maxZoomTransitionTime: 150     // 150ms
  maxMemoryUsage: 512           // 512MB
  maxCpuUsage: 80              // 80%
}

export class PerformanceMonitor {
  private metrics: GanttPerformanceMetrics[] = []
  private thresholds: PerformanceThresholds
  private readonly maxHistorySize = 100
  
  constructor(thresholds?: Partial<PerformanceThresholds>) {
    this.thresholds = { ...DEFAULT_THRESHOLDS, ...thresholds }
  }
  
  // 初回描画測定
  measureInitialRender<T>(renderFn: () => T, context: RenderContext): T {
    const start = performance.now()
    performance.mark('gantt-render-start')
    
    const result = renderFn()
    
    // フレーム完了を待つ
    requestAnimationFrame(() => {
      const end = performance.now()
      performance.mark('gantt-render-end')
      performance.measure('gantt-render', 'gantt-render-start', 'gantt-render-end')
      
      this.recordMetric('initialRenderTime', end - start, context)
    })
    
    return result
  }
  
  // ドラッグ応答測定
  measureDragResponse<T>(dragFn: () => T): T {
    const start = performance.now()
    
    const result = dragFn()
    
    requestAnimationFrame(() => {
      const duration = performance.now() - start
      this.recordMetric('dragResponseTime', duration)
    })
    
    return result
  }
  
  // ズーム遷移測定
  measureZoomTransition<T>(zoomFn: () => T): T {
    const start = performance.now()
    
    const result = zoomFn()
    
    requestAnimationFrame(() => {
      const duration = performance.now() - start
      this.recordMetric('zoomTransitionTime', duration)
    })
    
    return result
  }
  
  // メモリ使用量測定
  measureMemoryUsage(): number {
    if ('memory' in performance) {
      const memory = (performance as any).memory
      return Math.round(memory.usedJSHeapSize / 1024 / 1024) // MB
    }
    return 0
  }
  
  // 性能判定
  isPerformanceAcceptable(): boolean {
    const latest = this.getLatestMetrics()
    if (!latest) return true
    
    return (
      latest.initialRenderTime <= this.thresholds.maxInitialRenderTime &&
      this.getAverageDragTime() <= this.thresholds.maxDragResponseTime &&
      this.getAverageZoomTime() <= this.thresholds.maxZoomTransitionTime &&
      latest.memoryUsage <= this.thresholds.maxMemoryUsage
    )
  }
  
  // アラート判定
  shouldAlert(): PerformanceAlert[] {
    const alerts: PerformanceAlert[] = []
    const latest = this.getLatestMetrics()
    
    if (!latest) return alerts
    
    if (latest.initialRenderTime > this.thresholds.maxInitialRenderTime) {
      alerts.push({
        type: 'RENDER_SLOW',
        value: latest.initialRenderTime,
        threshold: this.thresholds.maxInitialRenderTime,
        severity: 'HIGH'
      })
    }
    
    // その他のアラート条件...
    
    return alerts
  }
  
  // 統計情報取得
  getPerformanceStats(): PerformanceStats {
    const recentMetrics = this.metrics.slice(-20) // 直近20件
    
    return {
      averageRenderTime: this.calculateAverage(recentMetrics, 'initialRenderTime'),
      averageDragTime: this.calculateAverage(recentMetrics, 'dragResponseTime'),
      averageZoomTime: this.calculateAverage(recentMetrics, 'zoomTransitionTime'),
      memoryTrend: this.calculateTrend(recentMetrics, 'memoryUsage'),
      totalMeasurements: this.metrics.length
    }
  }
}
```

### 6.2 usePerformanceMetrics Hook実装

```typescript
// apps/web/src/hooks/usePerformanceMetrics.ts
export const usePerformanceMetrics = (
  thresholds?: Partial<PerformanceThresholds>
) => {
  const monitor = useRef(new PerformanceMonitor(thresholds))
  const [metrics, setMetrics] = useState<GanttPerformanceMetrics[]>([])
  const [alerts, setAlerts] = useState<PerformanceAlert[]>([])
  
  // メトリクス更新の監視
  useEffect(() => {
    const intervalId = setInterval(() => {
      const latestMetrics = monitor.current.getAllMetrics()
      setMetrics(latestMetrics)
      
      const newAlerts = monitor.current.shouldAlert()
      setAlerts(newAlerts)
      
      // コンソール警告
      newAlerts.forEach(alert => {
        console.warn(`Performance Alert: ${alert.type} - ${alert.value}ms (threshold: ${alert.threshold}ms)`)
      })
    }, 1000)
    
    return () => clearInterval(intervalId)
  }, [])
  
  // 測定関数
  const measureInitialRender = useCallback(<T>(
    renderFn: () => T,
    context: RenderContext
  ): T => {
    return monitor.current.measureInitialRender(renderFn, context)
  }, [])
  
  const measureDrag = useCallback(<T>(dragFn: () => T): T => {
    return monitor.current.measureDragResponse(dragFn)
  }, [])
  
  const measureZoom = useCallback(<T>(zoomFn: () => T): T => {
    return monitor.current.measureZoomTransition(zoomFn)
  }, [])
  
  // 統計情報
  const stats = useMemo(() => {
    return monitor.current.getPerformanceStats()
  }, [metrics])
  
  // 性能状態
  const isAcceptable = useMemo(() => {
    return monitor.current.isPerformanceAcceptable()
  }, [metrics])
  
  return {
    // 測定関数
    measureRender: measureInitialRender,
    measureDrag,
    measureZoom,
    
    // データ
    metrics,
    alerts,
    stats,
    
    // 状態
    isAcceptable,
    hasAlerts: alerts.length > 0
  }
}
```

### 6.3 react-window統合実装

#### VirtualizedGanttGrid実装
```typescript
// apps/web/src/components/gantt/optimized/VirtualizedGanttGrid.tsx
import { FixedSizeList as List } from 'react-window'

interface VirtualizedGanttGridProps {
  tasks: GanttTask[]
  config: GanttTimelineConfig
  viewport: GanttViewport
  selectedTaskIds: Set<string>
  onTaskClick: (task: GanttTask) => void
}

export const VirtualizedGanttGrid: React.FC<VirtualizedGanttGridProps> = ({
  tasks,
  config,
  viewport,
  selectedTaskIds,
  onTaskClick
}) => {
  const containerHeight = tasks.length * viewport.rowHeight
  const visibleRowCount = Math.ceil(viewport.height / viewport.rowHeight)
  
  // 仮想化用データ準備
  const itemData = useMemo(() => ({
    tasks,
    config,
    viewport,
    selectedTaskIds,
    onTaskClick,
    taskIndexMap: new Map(tasks.map((task, index) => [task.id, index]))
  }), [tasks, config, viewport, selectedTaskIds, onTaskClick])
  
  return (
    <div className="virtualized-gantt-grid">
      {/* 背景グリッド（仮想化対象外） */}
      <BackgroundGrid config={config} viewport={viewport} />
      
      {/* 仮想化タスク行 */}
      <List
        height={Math.min(containerHeight, viewport.height)}
        itemCount={tasks.length}
        itemSize={viewport.rowHeight}
        itemData={itemData}
        overscanCount={5} // パフォーマンス調整
      >
        {OptimizedTaskRow}
      </List>
    </div>
  )
}

// 仮想化対応タスク行
const OptimizedTaskRow: React.FC<ListChildComponentProps> = ({ 
  index, 
  style, 
  data 
}) => {
  const { tasks, config, viewport, selectedTaskIds, onTaskClick, taskIndexMap } = data
  const task = tasks[index]
  
  // タスクバー位置計算（最適化済み）
  const taskBarPosition = useMemo(() => {
    const startX = viewport.timeScale(task.startDate) || 0
    const endX = viewport.timeScale(task.endDate) || 0
    const width = Math.max(endX - startX, 4)
    
    return { startX, width }
  }, [task.startDate, task.endDate, viewport.timeScale])
  
  return (
    <div style={style} className="virtual-task-row">
      <OptimizedGanttBar
        task={task}
        position={taskBarPosition}
        isSelected={selectedTaskIds.has(task.id)}
        onClick={onTaskClick}
      />
    </div>
  )
}
```

---

## 7. 実装スケジュール

### 7.1 Phase 2.1: テレメトリ基盤（2日）

#### Day 1: Performance Metrics・Monitor実装
```
09:00-11:00 (2h) | GanttPerformanceMetrics interface設計
11:00-13:00 (2h) | PerformanceMonitor class実装（基本機能）
14:00-16:00 (2h) | PerformanceMonitor class実装（測定ロジック）
16:00-18:00 (2h) | 単体テスト作成・検証
```

#### Day 2: Hooks統合・測定ポイント実装
```
09:00-13:00 (4h) | usePerformanceMetrics hook実装
14:00-16:00 (2h) | GanttChart.tsx測定ポイント統合
16:00-17:00 (1h) | 自動アラート機能実装
17:00-18:00 (1h) | テレメトリ動作確認
```

### 7.2 Phase 2.2: 性能最適化（2日）

#### Day 3: 仮想化・描画最適化
```
09:00-12:00 (3h) | VirtualizedGanttGrid基本実装
12:00-15:00 (3h) | react-window統合・調整
15:00-17:00 (2h) | SVG差分描画実装
17:00-18:00 (1h) | 仮想化動作確認
```

#### Day 4: 計算最適化・統合テスト
```
09:00-12:00 (3h) | 依存関係計算インデックス最適化
12:00-15:00 (3h) | セレクター最適化・デバウンス強化
15:00-17:00 (2h) | 統合テスト・性能測定
17:00-18:00 (1h) | 最終検証・ドキュメント更新
```

### 7.3 マイルストーン

| マイルストーン | 完了予定 | 達成基準 |
|---------------|----------|----------|
| **MS1: テレメトリ基盤完成** | Day 2 17:00 | 測定機能動作、データ収集開始 |
| **MS2: 仮想化統合完成** | Day 3 17:00 | react-window統合、スクロール動作 |
| **MS3: 性能最適化完成** | Day 4 15:00 | 計算最適化、差分描画実装 |
| **MS4: Phase 2完成** | Day 4 18:00 | 性能要件達成、全機能動作確認 |

---

## 8. 受入基準・Definition of Done

### 8.1 性能要件（必達）
- [ ] **初回描画時間 < 1.5秒**（1,000 Issue環境、Chrome）
- [ ] **ドラッグ応答時間 < 100ms**（平均値、10回測定）
- [ ] **ズーム切替時間 < 150ms**（全ズームレベル対応）
- [ ] **メモリリーク無し**（30分連続操作後、増加<10%）
- [ ] **CPU使用率 < 80%**（通常操作時の平均値）

### 8.2 機能要件
- [ ] パフォーマンスメトリクス自動収集（1秒間隔）
- [ ] リアルタイム性能監視（コンソール出力）
- [ ] 性能異常の自動検出（閾値超過アラート）
- [ ] react-window仮想化（1,000タスク環境）
- [ ] SVG差分描画（変更タスクのみ更新）
- [ ] 依存関係計算最適化（O(n²)→O(n)）

### 8.3 品質要件
- [ ] TypeScript型安全性維持（tsc --noEmit成功）
- [ ] 単体テスト通過率 ≥ 90%（新規実装機能）
- [ ] E2Eテスト通過（既存シナリオ + 性能シナリオ）
- [ ] 既存機能互換性100%（回帰テスト全通過）
- [ ] パフォーマンステスト全項目クリア

### 8.4 実装品質要件
- [ ] ESLint警告0件（新規・修正ファイル）
- [ ] コードレビュー完了（実装方針の妥当性確認）
- [ ] ドキュメント更新（性能最適化に関する記載）
- [ ] feature flag対応（段階的有効化可能）

---

## 9. パフォーマンステスト詳細

### 9.1 テスト環境設定

#### ハードウェア要件
- **CPU**: Intel i5相当以上
- **Memory**: 16GB以上
- **ブラウザ**: Chrome 120+（DevTools対応）

#### テストデータ準備
```typescript
// テストデータ仕様
interface PerformanceTestData {
  tasks: {
    count: 1000                    // タスク数
    hierarchyDepth: 5             // 階層の深さ
    dependencyRatio: 0.3          // 依存関係の割合
  }
  dateRange: {
    startDate: '2024-01-01'       // 開始日
    endDate: '2024-12-31'         // 終了日
    span: 365                     // 日数
  }
  complexity: {
    assignees: 50                 // 担当者数
    projects: 10                  // プロジェクト数
    statuses: 5                   // ステータス種類
  }
}
```

### 9.2 測定シナリオ詳細

#### シナリオ1: 初回描画性能
```typescript
describe('初回描画性能テスト', () => {
  test('1,000タスク環境での初回描画', async () => {
    // 1. テストデータ準備
    await setupTestData(1000)
    
    // 2. 測定開始
    const startTime = performance.now()
    
    // 3. Ganttチャート描画
    await page.goto('/gantt')
    await page.waitForSelector('[data-testid="gantt-chart"]')
    
    // 4. 描画完了待機
    await page.waitForFunction(() => {
      const chart = document.querySelector('[data-testid="gantt-chart"]')
      return chart?.children.length > 0
    })
    
    // 5. 時間測定
    const renderTime = performance.now() - startTime
    
    // 6. 検証
    expect(renderTime).toBeLessThan(1500) // < 1.5秒
  })
})
```

#### シナリオ2: ドラッグ応答性能
```typescript
describe('ドラッグ応答性能テスト', () => {
  test('タスクバードラッグの応答時間', async () => {
    // 準備
    await setupTestData(1000)
    await page.goto('/gantt')
    
    const taskBar = await page.locator('[data-testid="task-bar"]').first()
    
    // 複数回測定
    const responseTimes: number[] = []
    
    for (let i = 0; i < 10; i++) {
      const startTime = performance.now()
      
      // ドラッグ操作
      await taskBar.dragTo(taskBar, { 
        sourcePosition: { x: 10, y: 10 },
        targetPosition: { x: 50, y: 10 }
      })
      
      // 視覚更新完了待機
      await page.waitForTimeout(16) // 1フレーム
      
      const responseTime = performance.now() - startTime
      responseTimes.push(responseTime)
    }
    
    // 平均応答時間検証
    const averageTime = responseTimes.reduce((a, b) => a + b) / responseTimes.length
    expect(averageTime).toBeLessThan(100) // < 100ms
  })
})
```

### 9.3 継続監視設定

#### 自動パフォーマンス監視
```typescript
// apps/web/src/lib/performance-monitoring.ts
export class ContinuousPerformanceMonitor {
  private interval: NodeJS.Timeout | null = null
  
  startMonitoring(intervalMs: number = 5000): void {
    this.interval = setInterval(() => {
      const metrics = this.collectMetrics()
      
      // 閾値チェック
      if (this.exceedsThresholds(metrics)) {
        this.alertPerformanceIssue(metrics)
      }
      
      // データ保存（任意）
      this.persistMetrics(metrics)
    }, intervalMs)
  }
  
  private collectMetrics(): PerformanceMetrics {
    return {
      memoryUsage: this.getMemoryUsage(),
      renderFrameRate: this.getFrameRate(),
      taskCount: this.getCurrentTaskCount(),
      timestamp: Date.now()
    }
  }
}
```

---

## 10. リリース・デプロイ戦略

### 10.1 段階的リリース

#### Stage 1: Development Environment（Day 3）
- **対象**: 開発環境での動作確認
- **目的**: 基本機能動作・統合確認
- **参加者**: 開発チーム内

#### Stage 2: Feature Flag Release（Day 4）
- **対象**: 本番環境でのfeature flag制御
- **目的**: 一部ユーザーでの性能検証
- **制御**: 環境変数による有効化制御

#### Stage 3: Full Release（Phase 3開始時）
- **対象**: 全ユーザー向けリリース
- **前提**: Phase 2受入基準完全達成

### 10.2 フォールバック戦略

#### 性能劣化時の対応
```typescript
// 緊急時設定
const emergencyConfig = {
  enableVirtualization: false,     // 仮想化無効化
  maxTasksToRender: 500,          // 描画タスク数制限
  disableAnimations: true,        // アニメーション無効化
  simplifiedDependencies: true    // 依存関係表示簡略化
}
```

---

## 11. 成果物・ドキュメント

### 11.1 技術成果物
- [ ] 動作するWebアプリケーション（性能最適化適用済み）
- [ ] PerformanceMonitorライブラリ
- [ ] react-window統合コンポーネント群
- [ ] パフォーマンステストスイート

### 11.2 ドキュメント成果物
- [ ] 性能最適化技術仕様書
- [ ] パフォーマンステスト実行手順書
- [ ] 継続監視設定ガイド
- [ ] トラブルシューティングマニュアル

### 11.3 測定・分析データ
- [ ] ベンチマーク結果レポート
- [ ] 最適化前後性能比較データ
- [ ] メモリ使用量分析レポート
- [ ] ユーザビリティ影響評価

---

## 12. Phase 3準備事項

### 12.1 Phase 3への引き継ぎ事項
- 性能監視データの活用方法
- 最適化機能のメンテナンス方針
- 追加パフォーマンス改善の可能性

### 12.2 技術的負債・改善提案
- react-window以外の仮想化技術検討
- WebWorker活用による計算処理分離
- Service Worker活用によるキャッシュ最適化

---

## 13. 成功・失敗条件

### 13.1 成功条件（Phase 2完了条件）
1. **性能要件完全達成**: 1.5s/100ms/150ms基準をすべてクリア
2. **機能互換性維持**: 既存機能の100%動作保証
3. **テレメトリ稼働**: 継続的な性能監視開始
4. **品質基準達成**: テスト通過率・型安全性維持

### 13.2 失敗・警告条件
1. **性能要件未達**: いずれかの基準が50%以上超過
2. **重大回帰バグ**: 既存機能の動作不良
3. **実装未完了**: 計画された機能の80%未満完了

### 13.3 緊急時対応プラン
- **機能削減**: react-window仮想化のみ実装、他機能はPhase 3延期
- **基準緩和**: 一時的に目標値を1.8s/120ms/180msに調整
- **段階リリース**: テレメトリ基盤のみ先行リリース

---

**Status**: 実装プラン策定完了  
**Next Phase**: IMPLEMENT  
**Priority**: Phase 2.1（テレメトリ基盤）から実装開始

**工数**: 4日間（32時間）  
**成功確率**: 85%（高確度）  
**主要リスク**: react-window統合複雑さ、性能目標達成